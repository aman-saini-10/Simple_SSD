#include "icl/global_point.hh"
SimpleSSD::ICL::AbstractCache* globalCache = nullptr;
int block_index= -1;
long test_read=0;
long totalFtlReads=0;
long undoCaching=0;
long overwrittenPages=0;
long all_cached_pages=0;
long erase_counter=0;
long eraser=0;
uint32_t liner=0;
std::vector<SimpleSSD::ICL::Line> evictLines;
int tempo=0;
int input_trace=0;
std::vector<SimpleSSD::ICL::Line> linesToRemove;
std::vector<uint32_t>erased_block_id;
std::vector<uint64_t>movePagesToCache;
std::vector<uint64_t>movePagesToBlock;
 long  myIoCount=0;
 bool terminator=false;
 bool logical_check=false;
 int lpnUpdate=0;
 int gcCounter=0;
 uint64_t ioQueueDepth=0;
 long submittedIOs=0;
 bool evictLinesCalled=false;
 bool switchToEvictions=false;
 int FreePageInErasedBlock=0;
 int glocalEvictor=0;
 long dirtyStatusCounter=0;// this is for checking how many entries have been made dirty
 uint32_t currentBlockId=0;
 bool getin=false;
 bool getin2=true;
 uint64_t iclCount=0;
 bool putPagesInCache=false;
 uint64_t totalPagesMovedFromBlockToCache=0;
 uint64_t totalPagesMovedFromBlockToBlock=0;
 uint64_t totalPagesVictimToFresh=0;
 uint64_t totalDirtyStatusUpdate=0;
 bool cachedGC=false;
  uint64_t totalEvictions=0;
 uint64_t totalDirtyEvictions=0;
 uint64_t cmtSullSize=0;
 std::unordered_map<uint64_t, uint32_t> gcTimmingBucket; 
 std::unordered_map<uint32_t, uint32_t> pageMoveBucket;
 std::unordered_map<uint64_t, uint32_t> frequencyBucket; 
std::unordered_map<uint64_t, uint32_t> ReadBusyBucket; 
std::unordered_map<uint64_t, uint32_t> WriteBusyBucket; 
std::unordered_map<uint64_t, uint64_t> PageReuseBucket;
std:: unordered_map<uint64_t, uint64_t> LbaAccessFrequency;
std::unordered_map<uint64_t, uint32_t> HotnessMeter; 
std::unordered_map<uint64_t, uint32_t> gcInvocationBucket;
std::unordered_map<uint64_t, palInfo> eraseMapBucket;
std::unordered_map<uint64_t, uint32_t> ReadMap; 
std::unordered_map<uint64_t, uint32_t> WriteMap; 
std:: unordered_map<uint64_t, uint64_t> cmtEntryEvictionAccessFrequency;
std::string externalFileName;
uint64_t totalTimesEvictionCalled=0;
std:: unordered_map<uint64_t, uint64_t> AddressReuseDistanceMap;
std:: string outputPath="/home/waqar/MappingTableWork/mappingWrokStats/buckets/";
uint64_t TotalCleanEvicitons1=0;
uint64_t TotalCleanEvicitons2=0;
bool pageisPresentInSSD=false;
uint64_t timeDiff=8;
uint64_t startingTick=0;
std::chrono::high_resolution_clock::time_point startTime = std::chrono::high_resolution_clock::now();
int victimSelectionPolicy=0;
uint64_t ghostCacheSize=0;//4194304
uint64_t ghostEvictCacheSize=0;
uint64_t movePageFromGhostToCacheReads=0;
uint64_t movePageFromGhostToCacheWrites=0;
bool eraserIO=false;
SSDInfo ssdparameters;
uint32_t ssdInternals[4];
bool multiVictimBlock=false;;
bool SameChipmultiVictimBlock=false;
std::unordered_map<uint64_t, uint64_t> globalLBaReuseMap; ;
bool blockToBlockMovement=true;;
std:: unordered_map<uint32_t,victimBlockInfo> victimBlockSequence;;
std::unordered_map<uint64_t, uint32_t> lbaEvictionFrequency;
std::unordered_map<uint64_t, bool> pageEvictionIndicator;
bool doEvictionByGC=false;// this will help us to keep the track of which lpa has been evicted from the cache bacuae of GC
 uint64_t SimlationIORequests=5000000;;
 bool pageAwareofCache=true;
 uint64_t nlogicalpagesinSSD=0;
 std::unordered_map<uint64_t,std::vector<uint64_t>> optMap;
 bool optimalreplacementPolicy=false;
 bool useDeadOnArrivalPredictor=false ;
 bool printDeadOnArrival= false;
 bool usePortionOfCacheAsShadow=false;
 size_t cmtSize = 65568; 
 std:: unordered_map<uint64_t, uint64_t> AddressReuseDistanceClusters;
 bool enableCMT = true;;
//const SimpleSSD::ICL::EVICT_POLICY globalPolicy = (SimpleSSD::ICL::EVICT_POLICY)conf.readInt(CONFIG_FTL, FTL::FTL_GC_EVICT_POLICY);mv 
